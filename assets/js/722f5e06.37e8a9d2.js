"use strict";(self.webpackChunkcluster_docs=self.webpackChunkcluster_docs||[]).push([[3076],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>g});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=r.createContext({}),l=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},d=function(e){var t=l(e.components);return r.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,c=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),u=l(n),g=o,m=u["".concat(c,".").concat(g)]||u[g]||p[g]||a;return n?r.createElement(m,s(s({ref:t},d),{},{components:n})):r.createElement(m,s({ref:t},d))}));function g(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,s=new Array(a);s[0]=u;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:o,s[1]=i;for(var l=2;l<a;l++)s[l]=n[l];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},5516:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>p,frontMatter:()=>a,metadata:()=>i,toc:()=>l});var r=n(7462),o=(n(7294),n(3905));const a={id:"argocd-getting-started",title:"Getting started",sidebar_label:"Getting started",sidebar_position:2,tags:["Argocd"]},s="Getting Started",i={unversionedId:"argocd/argocd-getting-started",id:"argocd/argocd-getting-started",title:"Getting started",description:"To be able to interact with argocd in the cluster we need to install the argocd cli. For that we can once again use Chocolaty",source:"@site/docs/argocd/getting-started.md",sourceDirName:"argocd",slug:"/argocd/argocd-getting-started",permalink:"/cluster-docs/docs/argocd/argocd-getting-started",draft:!1,editUrl:"https://github.com/nimbit-software/cluster-docs/blob/master/docs/argocd/getting-started.md",tags:[{label:"Argocd",permalink:"/cluster-docs/docs/tags/argocd"}],version:"current",sidebarPosition:2,frontMatter:{id:"argocd-getting-started",title:"Getting started",sidebar_label:"Getting started",sidebar_position:2,tags:["Argocd"]},sidebar:"clusterDocs",previous:{title:"Overview",permalink:"/cluster-docs/docs/argocd/argocd-overview"},next:{title:"Databases",permalink:"/cluster-docs/docs/category/databases"}},c={},l=[{value:"Clusters",id:"clusters",level:3},{value:"Repos",id:"repos",level:3},{value:"Projects",id:"projects",level:3},{value:"Kustomized Helm",id:"kustomized-helm",level:2}],d={toc:l};function p(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"getting-started"},"Getting Started"),(0,o.kt)("p",null,"To be able to interact with argocd in the cluster we need to install the argocd cli. For that we can once again use Chocolaty "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash",metastring:"title=Argocd cli",title:"Argocd",cli:!0},"choco install argocd-cli\n")),(0,o.kt)("p",null,"When using argocd for the first time or when switching clusters we need to login. "),(0,o.kt)("p",null,"If we are not using an Ingress we will either have to forward the port using port-forward or we can change the service type to load balancer. "),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"If you have not set a new admin password for argocd then the password is stored in a secret called argocd-secret we can get the password using kubectl:"),(0,o.kt)("pre",{parentName:"admonition"},(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath={.data.password} | base64 -d; echo\n")),(0,o.kt)("p",{parentName:"admonition"},"Or we can store it in a variable to be used when logging in "),(0,o.kt)("pre",{parentName:"admonition"},(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"export ARGO_PWD=$(kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath={.data.password} | base64 -d;\n echo)\n"))),(0,o.kt)("p",null,"With our password we can now login"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash",metastring:"title=login",title:"login"},"# For our first login we will us the username admin\nexport ARGO_HOST=argocd.azure.nimbit.de\n\nargocd login $ARGO_HOST --name=admin --password=$ARGO_PWD\n")),(0,o.kt)("p",null,"Now we can take a look at what argo can do: "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"argocd --help\n\nargocd controls a Argo CD server\n\nUsage:\n  argocd [flags]\n  argocd [command]\n\nAvailable Commands:\n  account     Manage account settings\n  admin       Contains a set of commands useful for Argo CD administrators and requires direct Kubernetes access\n  app         Manage applications\n  appset      Manage ApplicationSets\n  cert        Manage repository certificates and SSH known hosts entries\n  cluster     Manage cluster credentials\n  completion  output shell completion code for the specified shell (bash or zsh)\n  context     Switch between contexts\n  gpg         Manage GPG keys used for signature verification\n  help        Help about any command\n  login       Log in to Argo CD\n  logout      Log out from Argo CD\n  proj        Manage projects\n  relogin     Refresh an expired authenticate token\n  repo        Manage repository connection parameters\n  repocreds   Manage repository connection parameters\n  version     Print version information\n\nFlags:\n      --auth-token string               Authentication token\n      --client-crt string               Client certificate file\n      --client-crt-key string           Client certificate key file\n      --config string                   Path to Argo CD config (default C:\\\\Users\\\\sooter/.config/argocd/config)\n      --core                            If set to true then CLI talks directly to Kubernetes instead of talking to Argo CD API server\n      --grpc-web                        Enables gRPC-web protocol. Useful if Argo CD server is behind proxy which does not support HTTP2.\n      --grpc-web-root-path string       Enables gRPC-web protocol. Useful if Argo CD server is behind proxy which does not support HTTP2. Set web root.\n  -H, --header strings                  Sets additional header to all requests made by Argo CD CLI. (Can be repeated multiple times to add multiple headers, also supports comma separated headers)\n  -h, --help                            help for argocd\n      --http-retry-max int              Maximum number of retries to establish http connection to Argo CD server\n      --insecure                        Skip server certificate and domain verification\n      --kube-context string             Directs the command to the given kube-context\n      --logformat string                Set the logging format. One of: text|json (default text)\n      --loglevel string                 Set the logging level. One of: debug|info|warn|error (default info)\n      --plaintext                       Disable TLS\n      --port-forward                    Connect to a random argocd-server port using port forwarding\n      --port-forward-namespace string   Namespace name which should be used for port forwarding\n      --server string                   Argo CD server address\n      --server-crt string               Server certificate file\n\nUse argocd [command] --help for more information about a command.\n")),(0,o.kt)("h3",{id:"clusters"},"Clusters"),(0,o.kt)("p",null,"For most of the argocd features we can use the UI there are however a few features that require us to use the CLI (at the time of writing this doc), one of those features is ",(0,o.kt)("strong",{parentName:"p"},"clusters")),(0,o.kt)("p",null,"Defining a cluster allows us to manage apps on an external cluster. Argocd can then monitor that cluster and deploy apps as needed without having to be installed on that cluster. "),(0,o.kt)("p",null,"Adding a cluster to argocd is very simple. The main requirement is that the cluster already exists in your current kubectl context "),(0,o.kt)("p",null,"If you installed kubectx you can view all your contexts by running: "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"kubectx\n")),(0,o.kt)("p",null,"After having identified the cluster you would like to add to argocd you and add it by simply running:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"argocd cluster add <cluster name>\n")),(0,o.kt)("p",null,"You can now deploy apps to this remote cluster using argocd"),(0,o.kt)("h3",{id:"repos"},"Repos"),(0,o.kt)("p",null,"In order to be able to access our git config we have to add a repository. Argocd will the poll this repository for changes and then apply them to the cluster. "),(0,o.kt)("p",null,"To add a new repository we can either use the UI or run:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"export GIT_REPO=<my git repository\nexport GIT_USERNAME=<username>\nexport GIT_PASSWORD=<password>\n\nargocd repo add $GIT_REPO --username $GIT_USERNAME --password $GIT_PASSWORD\n")),(0,o.kt)("h3",{id:"projects"},"Projects"),(0,o.kt)("p",null,"While it is possible to use the default project for all apps. It is much better practice to have at least one Project per Cluster. "),(0,o.kt)("p",null,"That way we can even define roles etc per project "),(0,o.kt)("admonition",{type:"info"},(0,o.kt)("p",{parentName:"admonition"},"Here is an example config for a project. Alternatively you can use the UI to create the project. "),(0,o.kt)("p",{parentName:"admonition"},"The example used wildcards for the whitelist but in a productive scenario it should be limited to a specific destination")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash",metastring:"title=Create Project",title:"Create",Project:!0},"\nexport PROJECT_NAME=my-project\nexport PROJECT_DESC=My project description\nexport PROJECT_SERVER=https://kubernetes.default.svc\nexport PROJECT_SOURCE_REPO=https://davidsooter@bitbucket.org/nimbit-iot/cluster-content.git\n\nkubectl apply -f - <<EOF\napiVersion: argoproj.io/v1alpha1\nkind: AppProject\nmetadata:\n  name: $PROJECT_NAME\n  namespace: argocd\n  # Finalizer that ensures that project is not deleted until it is not referenced by any application\n  finalizers:\n    - resources-finalizer.argocd.argoproj.io\nspec:\n  # Project description\n  description: $PROJECT_DESC\n\n  # Allow manifests to deploy from any Git repos\n  sourceRepos:\n  - '$PROJECT_SOURCE_REPO'\n\n  # Only permit applications to deploy to the guestbook namespace in the same cluster\n  destinations:\n  - name: '*'\n    namespace: '*'\n    server: $PROJECT_SERVER\n\n  # Deny all cluster-scoped resources from being created, except for Namespace\n  clusterResourceWhitelist:\n  - group: '*'\n    kind: '*'\n\n  # Allow all namespaced-scoped resources to be created, except for ResourceQuota, LimitRange, NetworkPolicy\n  namespaceResourceBlacklist:\n  - group: ''\n    kind: ResourceQuota\n  - group: ''\n    kind: LimitRange\n  - group: ''\n    kind: NetworkPolicy\n\n  # Deny all namespaced-scoped resources from being created, except for Deployment and StatefulSet\n  namespaceResourceWhitelist:\n  - group: 'apps'\n    kind: Deployment\n  - group: 'apps'\n    kind: StatefulSet\n\n  # Enables namespace orphaned resource monitoring.\n  orphanedResources:\n    warn: true\n\n  roles:\n  # A role which provides read-only access to all applications in the project\n  - name: read-only\n    description: Read-only privileges to $PROJECT_NAME\n    policies:\n    - p, proj:$PROJECT_NAME:read-only, applications, get, $PROJECT_NAME/*, allow\n    groups:\n    - my-oidc-group\n\n  # A role which provides sync privileges to only the guestbook-dev application, e.g. to provide\n  # sync privileges to a CI system\n  - name: ci-role\n    description: Sync privileges for guestbook-dev\n    policies:\n    - p, proj:$PROJECT_NAME:ci-role, applications, sync, $PROJECT_NAME/guestbook-dev, allow\n\n    # NOTE: JWT tokens can only be generated by the API server and the token is not persisted\n    # anywhere by Argo CD. It can be prematurely revoked by removing the entry from this list.\n    jwtTokens:\n    - iat: 1535390316\n\n  # Sync windows restrict when Applications may be synced. https://argo-cd.readthedocs.io/en/stable/user-guide/sync_windows/\n  # syncWindows:\n  # - kind: allow\n  #   schedule: '10 1 * * *'\n  #   duration: 1h\n  #   applications:\n  #     - '*-prod'\n  #   manualSync: true\n  # - kind: deny\n  #   schedule: '0 22 * * *'\n  #   duration: 1h\n  #   namespaces:\n  #     - default\n  # - kind: allow\n  #   schedule: '0 23 * * *'\n  #   duration: 1h\n  #   clusters:\n  #     - in-cluster\n  #     - cluster1\nEOF\n\n")),(0,o.kt)("h2",{id:"kustomized-helm"},"Kustomized Helm"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl apply -f - <<EOF\napiVersion: v1\nkind: ConfigMap\nmetadata:\n  name: argocd-cm\n  namespace: argocd\n  labels:\n    app.kubernetes.io/part-of: argocd\ndata:\n  configManagementPlugins: |\n    - name: kustomized-helm\n      init:\n        command: [/bin/sh, -c]\n        args: [helm dependency build || true]\n      generate:\n        command: [/bin/sh, -c]\n        args: [helm template . --name-template $ARGOCD_APP_NAME --namespace $ARGOCD_APP_NAMESPACE --include-crds > all.yaml && kustomize build]\nEOF\n\n")))}p.isMDXComponent=!0}}]);